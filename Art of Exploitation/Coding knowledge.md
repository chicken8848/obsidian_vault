## Memory Segment
### text
Code segment. Assembled machine language instructions of the program are located.
When a program executes, the EIP is set to the first instruction in the text segment. 

Processor follows the execution loop:
1. Reads the instruction that EIP is pointing to
2. Adds the byte length of the instruction to EIP
3. Executes the instruction that was read in step 1
4. Back to step 1

Write permissions are disabled int he text segment.
It is not store variables, only code. 
Any attempt to write to this segment of memory will cause the program to alert the user, and off itself.

Fixed size
### data
Filled with initialized global and static variables
Fixed size
### bss
Filled with uninitialized global and static variables
Fixed size
### heap
Segment of memory that the programmer can directly control. Blocks of memory in this segment can be allocated and used for whatever the programmer might need.

Variable size

Memory within the heap is managed by allocator and dealloctor algorithms. 
Growth of heap moves downwards.

malloc returns the address to the start of the memory as a void pointer. 
If unable to allocate memory, it will simply return a NULL pointer with a value of 0
### stack
Variable size 
Temporary scratch pad to store local function variables and context during function calls.

This is what GDB's backtrace command looks at.

Since the context and the EIP must change when a function is called, the stack is used to remember all of the passed variables, 
the location the EIP should return to after the function is finished, and all the local variables used by that function.

ESP register used to keep track of the address of the end of the stack
EBP register/frame pointer/local base pointer ussed to reference local function variables in the current stack frame.

The Saved Frame Pointer (SFP) is used to restore EIP to the next instruction found after the function call.

#### Procedure prologue / function prologue
Saves the frame pointer on the stack, and they save stack memory for the local function variables.
Sometimes the function prologue will handle some stack alignment as well

depends on compiler

## C
### `fprintf`
Used to print an error message to standard error and the program exits. Similar to printf(), but its first argument is stderr, which is a standard filestream meant for displaying errors.

### Error check a malloc()
```c
void* errorchecked_malloc(unsigend int size) {
	void *ptr;
	ptr = malloc(size);
	if (ptr == NULL) {
		fprintf(stderr, "Error: could not allocate heap memory.\n");
		exit(-1);
	}
	return ptr;
}
```

### Structs
Structs are variables that can contain many other variables.

### Function Pointers
```c
int value, value2;
int (*function_ptr) ();
function_ptr = func_one;
value = function_ptr();
function_ptr = func_two;
value2 = function_ptr();
```

## File Access
### File descriptors
File descriptors use a set of low-level I/O functions

Four common functions:
`open()`, `close()`, `read()`, `write()`
All these will return -1 if there is an error.

`open()` function opens a file for reading and/or writing and returns a file descriptor (int)
`open()` flags (found in `fcntl.h` and `sys/stat.h`):
- `O_RDONLY` open file for read-only access
- `O_WRONLY` open file for write-only access
- `O_RDWR` Open file for both read and write access
- `O_APPEND` Write data at the end of the file
- `O_TRUNC` If the file already exists, truncate the file to 0 length
- `O_CREAT` Create the file if it doesn't exist

When `O_CREAT` flag is used in access mode, an additional argument is needed to define the file permissions of the newly created file.
- `S_IRUSR` Give file read permission for the user (Owner)
- `S_IWUSR` Give file write permission for the user (Owner)
- `S_IXUSR` Give the file execute permission for the user (owner)
- `S_IRGRP` Give the file read permission for the group
- `S_IWGRP` Give the file write permission for the group
- `S_IXGPR` Give the file execute permission for the group
- `S_IROTH` Give the file read permission for other (anyone)
- `S_IWOTH` Give the file write permission for other (anyone)
- `S_IXOTH` Give the file execute permission for other (anyone)
### File streams
File streams are a higher-level form of buffered I/O that is built on the lower-level functions.

### Permissions
Real uid: unique id given to user

Effective uid: effective uid given to anyone when running this program. For example, if `chmod u+s` to add `s` permission to file, then the effective id will be 0 (for root)

This is how the `chsh` program is able to allow any user to change his or her login shell stored in /etc/passwd