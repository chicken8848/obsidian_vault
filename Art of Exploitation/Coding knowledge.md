Static variables retain their value across function calls
## Memory Segment
### text
Code segment. Assembled machine language instructions of the program are located.
When a program executes, the EIP is set to the first instruction in the text segment. 

Processor follows the execution loop:
1. Reads the instruction that EIP is pointing to
2. Adds the byte length of the instruction to EIP
3. Executes the instruction that was read in step 1
4. Back to step 1

Write permissions are disabled int he text segment.
It is not store variables, only code. 
Any attempt to write to this segment of memory will cause the program to alert the user, and off itself.

Fixed size
### data
Filled with initialized global and static variables
Fixed size
### bss
Filled with uninitialized global and static variables
Fixed size
### heap
Segment of memory that the programmer can directly control. Blocks of memory in this segment can be allocated and used for whatever the programmer might need.

Variable size

Memory within the heap is managed by allocator and dealloctor algorithms. 
Growth of heap moves downwards.

malloc returns the address to the start of the memory as a void pointer. 
If unable to allocate memory, it will simply return a NULL pointer with a value of 0
### stack
Variable size 
Temporary scratch pad to store local function variables and context during function calls.

This is what GDB's backtrace command looks at.

Since the context and the EIP must change when a function is called, the stack is used to remember all of the passed variables, 
the location the EIP should return to after the function is finished, and all the local variables used by that function.

ESP register used to keep track of the address of the end of the stack
EBP register/frame pointer/local base pointer ussed to reference local function variables in the current stack frame.

The Saved Frame Pointer (SFP) is used to restore EIP to the next instruction found after the function call.

#### Procedure prologue / function prologue
Saves the frame pointer on the stack, and they save stack memory for the local function variables.
Sometimes the function prologue will handle some stack alignment as well

depends on compiler

## C
### `fprintf`
Used to print an error message to standard error and the program exits. Similar to printf(), but its first argument is stderr, which is a standard filestream meant for displaying errors.

### Error check a malloc()
```c
void* errorchecked_malloc(unsigend int size) {
	void *ptr;
	ptr = malloc(size);
	if (ptr == NULL) {
		fprintf(stderr, "Error: could not allocate heap memory.\n");
		exit(-1);
	}
	return ptr;
}
```

### Structs
Structs are variables that can contain many other variables.

### Function Pointers
```c
int value, value2;
int (*function_ptr) ();
function_ptr = func_one;
value = function_ptr();
function_ptr = func_two;
value2 = function_ptr();
```

## File Access
### File descriptors
File descriptors use a set of low-level I/O functions

Four common functions:
`open()`, `close()`, `read()`, `write()`
All these will return -1 if there is an error.

`open()` function opens a file for reading and/or writing and returns a file descriptor (int)
`open()` flags (found in `fcntl.h` and `sys/stat.h`):
- `O_RDONLY` open file for read-only access
- `O_WRONLY` open file for write-only access
- `O_RDWR` Open file for both read and write access
- `O_APPEND` Write data at the end of the file
- `O_TRUNC` If the file already exists, truncate the file to 0 length
- `O_CREAT` Create the file if it doesn't exist

When `O_CREAT` flag is used in access mode, an additional argument is needed to define the file permissions of the newly created file.
- `S_IRUSR` Give file read permission for the user (Owner)
- `S_IWUSR` Give file write permission for the user (Owner)
- `S_IXUSR` Give the file execute permission for the user (owner)
- `S_IRGRP` Give the file read permission for the group
- `S_IWGRP` Give the file write permission for the group
- `S_IXGPR` Give the file execute permission for the group
- `S_IROTH` Give the file read permission for other (anyone)
- `S_IWOTH` Give the file write permission for other (anyone)
- `S_IXOTH` Give the file execute permission for other (anyone)
### File streams
File streams are a higher-level form of buffered I/O that is built on the lower-level functions.

### Permissions
Real uid: unique id given to user

Effective uid: effective uid given to anyone when running this program. For example, if `chmod u+s` to add `s` permission to file, then the effective id will be 0 (for root)

This is how the `chsh` program is able to allow any user to change his or her login shell stored in /etc/passwd


## Terminal and scripts
`ctrl-z` suspends the process and puts it into the background
running `fg` resumes the suspended the process

Perl has a `crypt()` function that is a one-way hashing algorithm.
```sh
perl -e 'print crypt("password", "AA"). "\n"'
```

`nm` command lists symbols in object files
```sh
nm <name_of_prog>
```

the pipe command can be used to walk through cli automatically
```sh
perl -e 'print "1\n7\nn\n7\n"' | ./<some_prog>
```

The dash argument following the cat command tells the cat program to send standard input after the exploit buffer, returning control of the input.
Root shell would not display prompt but it is still accessible

## Format parameters

| Parameter | Input Type | Output Type                    |
| --------- | ---------- | ------------------------------ |
| %d        | value      | Decimal                        |
| %u        | value      | unsigned decimal               |
| %x        | value      | hexadecimal                    |
| %s        | pointer    | string                         |
| %n        | pointer    | number of bytes written so far |
```c
int count_one, count_two;

printf("The number of bytes written up to this point X%n is being stored in count_one, and the number of bytes being stored up to here X%n is being stored in count_two.\n", &count_one, &count_two);
```

### Direct Parameter Access
Direct parameter acceess allows parameters to be access directly by using the dollar sign qualifier. `%n$d` would access the nth parameter and display it as a decimal number.
```c
printf("7th: %7$d, 4th: %4$05d\n", 10, 20, 30, 40, 50, 60, 70, 80);
// 7th: 70, 4th: 00040
```


## .dtors and .ctors
In binary programs compiled with the GNU Compiler, special table sections called `.dtors` and `.ctors` are made for destructors and constructors, respectively. 

Note: As of gcc 4.7, it uses `.init_array` for `.ctors` and `.fini_array` for `.dtors`, still ends with `0x00000000` but may not start with `0xffffffff` (Thanks Mike Hommey!)

Constructor functions: executed before the `main()` function
Destructor functions: executed after the `main()` function

A function can be declared as a destructor function by defining the destructor attribute:
```c
static void cleanup(void) __attribute__((destructor));

main() {
	printf("when main() exits, the destructor is called..\n");
	exit(0);
}

void cleanup(void) {
	printf("In the cleanup function now..\n");
}
```

The behaviour of automatically executing a function on exit is controlled by the `.dtors` section of the binary.

This section:
- is an array of 32-bit addresses
  - always begins with `0xffffffff`
  - always ends with the NULL address of `0x00000000`
- terminated by a NULL address
- between these are the addresses of all the function that have been declared with the destructor attribute

`objdump` command can be used to show the actual contents of each section
```sh
objdump -s -j .dtors ./<target_prog> # or .fini_array for gcc ver>=4.7
```
The output is a bit confusing:
```
Contents of section .dtors:
 80495ac ffffffff e8830408 00000000 
 ^-----^ ^------^ ^------^ ^------^
	|        |        |        |------ End of .dtors section
	|        |        |--------------- Actual bytes are shown as opposed to DWORDs, and appear backwards
	|        |------------------------ Start of .dtors section
    |--------------------------------- showing the address where .dtors section is located
```
To clarify: is `.init_array` and `.fini_array` backwards? Not sure.

The `.dtors` section is also writeable. You could do a
```sh
objdump -h ./<target_prog>
```
To verify that it is not `READONLY`

## The global offset table
Since a program could use a function in a shared library many times, it's useful to have a table to reference all teh functions.
There is a special section in compiled programs just for that - the procedure linking table (PLT)
It contains of many jump instruction, each one corresponding to the address of a function. Each time a shared function needs to be called, control will pass throught the PLT

You can see the section `.plt` by running:
```sh
objdump -d -j .plt <target_prog>
```

However, modern toolchains often merge or omit `.plt` and is instead built as a `Position-Independent Executable File`.
Check using:
```sh
readelf -h <target_prog> | grep Type
```

The jump addresses in the `.plt` are not jumping to addresses but to pointers to addresses.

These addresess exist in another section called the global offset table (GOT), which is writeable.

You can display the addresses by displaying the dynamic relocation entries for the binary:
```sh
objdump -R <target_program>
```
and look for a corresponding address (with the `.plt`)

# Networking
## OSI Model
The purpose of the OSI model is to provide standards to allow hardware to focus on one particular aspect of communication and ignore others.
- Physical layer (communicates raw bit streams)
- Data link layer (transferring data between two points, error correction, flow control)
- Network layer (Pass information between lower and higher layers, addressing and routing is here)
- Transport layer (transparent transfer of data between systems)
- Session layer (Establish and maintain connections between network applications)
- Presentation layer (Encryption, encoding, data compression)
- Application layer (Keep track of the requirements of the application)

Encapsulation: each wrapped layer contains a header and a body.
The header contains the protocol information needed for that layer.
The body contains the data for that layer.

The operating system takes care of the details of network encapsulation.
We then write network programs using the network interface of the OS.

## Sockets
A socket is a standard way to perform network communication through the OS.
A socket can be thought of as an endpoint to a connection (although they are just abstractions).
A socket can be used to send or receive data over a network.
Most common sockets are:
- Stream sockets
- Datagram sockets

Stream sockets: 
- Two-way communication, based on TCP.
- Packets of data will arrive without errors and in sequence

Datagram sockets:
- One-way and unreliable, based on UDP
- Commonly used in networked games and streaming media
- No TCP overhead

### Socket functions
Sockets behave a lot like files since they use file descriptors to identify themselves. you can even use `read()` and `write()` to receive and send data

However, there are several specific functions for dealing with sockets:
```c
// From sys/sockets.h
socket(int domain, int type, int protocol) // creates a new socket, returns fd or -1 on error
connect(int fd, struct sockaddr *remote_host, socklen_t addr_length) // connects a socket (identified by fd) to a remote host. Returns 0 on success and -1 on error
bind(int fd, struct sockaddr *local_addr, socklen_t addr_length) // Binds a socket to a local address so it can listen for incoming connections. Returns 0 on success and -1 on error
listen(int fd, int backlog_queue_size) // Listens for incoming connections and queues connection requests up to backlog_queue_size. Returns 0 on success and -1 on error
accept(int fd, sockaddr *remote_host, socklen_t *addr_length) // Accepts an incoming connection on a bound socket. Addr info from remote host is written into remote_host and actual size of the address structure is written into addr_length. Returns new socket file descriptor or -1 on error
send(int fd, void *buffer, size_t n, int flags) // Sends n bytes from buffer to socket fd; returns the number of bytes sent or -1 on error
recv(int fd, void *buffer, size_t n, int flags) // Receives n bytes from socket fd into buffer; returns the number of bytes received or -1 on error
```
When a socket is created, the domain, type, and protocol of the socket must be specified.
The protocol family (domain) and types can be found in `/usr/bin/include/bits/socket.h`
The protocol argument is almost always 0. Which allows for multiple protocols within a protocol family, so this argument is used to select one of the protocols from the family. In practice, protocol families only have one protocl which is why it is almost always 0.

### Socket addresses
Structure is defined in `/usr/include/bits/socket.h`
```c
/* Structure describing a generic socket address.  */
struct __attribute_struct_may_alias__ sockaddr
  {
    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
    char sa_data[14];		/* Address data.  */
  };
```

`SOCKADDR_COMMON` is defined in the included `bits/sockaddr.h` file, which defines (as an `int`) the address family of the address, and the rest of the structure is saved for address data.
Since sockets can communicate using a variety of protocol families, each with their own way of defining endpoint addresses, the definition of an address must also be variable, depending on the address family.

Possible address families are also defined in `usr/include/bits/socket.h`
```c
/* Address families.  */
#define AF_UNSPEC	PF_UNSPEC
#define AF_LOCAL	PF_LOCAL
#define AF_UNIX		PF_UNIX
#define AF_FILE		PF_FILE
#define AF_INET		PF_INET
#define AF_AX25		PF_AX25
#define AF_IPX		PF_IPX
#define AF_APPLETALK	PF_APPLETALK
#define AF_NETROM	PF_NETROM
#define AF_BRIDGE	PF_BRIDGE
#define AF_ATMPVC	PF_ATMPVC
#define AF_X25		PF_X25
#define AF_INET6	PF_INET6
....
```
An address can contain different types of information, depending on the address family, there are several other address structures that contain, in the address data section, common elements from the `sockaddr` structure as well as information specific to the address family.

The `socket()` function will simply accept a pointer to a `sockaddr` structure, which allows the socket functions to operate on a variety of protocols.

The parallel socket address structure for `AF_INET` is defined in `/usr/include/netinet/in.h` file
```c
/* Structure describing an Internet socket address.  */
struct __attribute_struct_may_alias__ sockaddr_in
  {
    __SOCKADDR_COMMON (sin_);
    in_port_t sin_port;			/* Port number.  */
    struct in_addr sin_addr;		/* Internet address.  */

    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr)
                            - __SOCKADDR_COMMON_SIZE
                            - sizeof (in_port_t)
                            - sizeof (struct in_addr)];
  };
```
`SOCKADDR_COMMON` at the top of the structure is the short int used to defined the address family, similar to above.
Since a socket endpoint address consists of an Internet address and a port number, these are the next two values in the structure.
- `in_addr` contains a 32-bit number, used for internet address
- port number is a 16-bit short
- the rest is 8 bytes of padding to fill out the rest of the `sockaddr` structure. (for typecasting, cuz they have to be the same size)

### Network Byte Order
The port and IP address in the `AF_INET` socket address structure are expected to follow the network byte ordering, which is big-endian. Which is the opposite of `x86` little-endian byte ordering, so they must be converted.
Here are a list of common byte order conversion functions defined in `netinet/in.h` and `arpa/inet.h` include files:
```c
#ifdef __OPTIMIZE__
/* We can optimize calls to the conversion functions.  Either nothing has
   to be done or we are using directly the byte-swapping functions which
   often can be inlined.  */
# if __BYTE_ORDER == __BIG_ENDIAN
/* The host byte order is the same as network byte order,
   so these functions are all just identity.  */
# define ntohl(x)	__uint32_identity (x)
# define ntohs(x)	__uint16_identity (x)
# define htonl(x)	__uint32_identity (x) 
# define htons(x)	__uint16_identity (x) 
# else
#  if __BYTE_ORDER == __LITTLE_ENDIAN
#   define ntohl(x)	__bswap_32 (x) // network to host long, convert 32-bit integer from network byte order to host byte order
#   define ntohs(x)	__bswap_16 (x) // network to host short, convert 16-bit integer from network byte order to host byte order
#   define htonl(x)	__bswap_32 (x) // host to network long, convert 32-bit integer from host's byte order to network byte order
#   define htons(x)	__bswap_16 (x) // host to network short, convert 16-bit integer from host byte order to network byte order
#  endif
# endif
#endif
```
For compatibility with all architectures, these conversion functions should still be used even if the host is using a processor with big-endian byte ordering.

### Internet Address Conversion
Functions defined in the `/usr/include/arpa/inet.h` file, are useful to convert IPv4 address to and from a 32-bit integer in network byte order.
```c
/* Convert Internet number in IN to ASCII representation.  The return value
   is a pointer to an internal array containing the string.  */
extern char *inet_ntoa (struct in_addr __in) __THROW;
/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data and store the result in the structure INP.  */
extern int inet_aton (const char *__cp, struct in_addr *__inp) __THROW;
```


### The Lower Layers
#### Data-Link layer
This layer provides a way to address and send messages to anyone else locally, as well as to figure out who is there.
Ethernet exists on this layer, providing a standard addressing system for all Ethernet devices, known as Media Access Control (MAC) addresses.
An ethernet device is assigned a globally unique address consisting of six bytes, usually written in hexadecimal in the form `xx:xx:xx:xx:xx:xx`. Also referred to as hardware addresses.

An ethernet header is 14 bytes in size and contains the source and destination MAC addresses for this Ethernet packet.
There is also a special broadcast address, consisting of all binary 1's `ff:ff:ff:ff:ff:ff`
- Any ethernet packet sent to this address will be sent to all the connected devices.

The MAC address of a network device isn't meant to change, but its IP address may change regularly
- IP addresses don't exist at this level, only hardware addresses.
Hence, a method is required to correlate the two addressing schemes, in Ethernet, this is known as Address Resolution Protocol (ARP)

##### ARP
This protocol associates an IP address with a piece of hardware.
There are 4 different types of ARP messages, but the two most important are:
- ARP request messages
- ARP reply messages

Any packet's ethernet header includes a value type that describes the packet, which could be
- ARP-type message
- IP packet

The protocol goes like this
1. system-1 sends ARP request, which is a message, sent to the broadcast address (ff:ff:ff:ff:ff:ff for everyone), that contains sender's IP address and MAC address and says "hey who has this ip?"
2. system-2 (which has the ip) sends an ARP reply, saying "This is my MAC address, I have this IP address."
3. Most implementations will cache the MAC/IP address pairs received in ARP replies so that the protocol is not required for every single packet
No system can communicate with the other until they know each other's MAC addresses.


#### Network Layer
The protocol used at this layer for internet addressing and delivery is called Internet Protocol (IP); majority of the internet uses IPv4
It is a 4 byte arrangement in the form of `xx.xx.xx.xx` The IP header for packets in this layer is 20 bytes in size and consists of various fields and bitflags and is defined in [RFC 791](https://www.rfc-editor.org/rfc/rfc791.html)

Check chapter 3.1 for the header format; it also carries a checksum to help detect transmission errors, and fields to deal with packet fragmentation.

IP is mostly used to transmit packets wrapped in higher layers. However, Internet Control Message Protocol (ICMP) packets also exist on this layer.

IP deals with limitations on packet size by fragmenting packets into smaller packet fragments. IP headers are put on each fragment and are sent off.


#### Transport Layer
The two major protocols at this layer are the Transmission Control Protocol (TCP) and User Datagram Protocol (UDP).

TCP is most commonly used:
- telnet
- HTTP
- SMTP
- FTP
Popular for providing a transparent, reliable and bidirectional connection between 2 IP addresses.
Stream sockets use TCP/IP connections
If packets arrive jumbled up or out of arder, TCP will make sure they're put back in order before handing the data up to the next layer.
If packets are lost, the destination will hold on to the packets while the source retransmits the missing packets.

All this functionality is made possible by TCP flags, and by tracking values called sequence numbers.

TCP flags:
| TCP Flag | Meaning         | Purpose                                                                   |
| URG      | Urgent          | Identifies important data                                                 |
| ACK      | Acknowledgement | Acknowledges a packet; it is turned on for the majority of th econnection |
| PSH      | Push            | Tells the receiver to push the data through instead of buffering it       |
| RST      | Reset           | Resets a connection                                                       |
| SYN      | Synchronize     | Synchronizes sequence numbers at the beginning of a connection            |
| FIN      | Finish          | Gracefully closes a connection when both sides say goodbye                                                                          |
And they are stored in the TCP header along with the source and destination ports.
See also: [TCP Procotol](https://www.rfc-editor.org/rfc/rfc793.html)

The protocol goes something like this:
1. When a client wants to open a connection with a server, a packet with the SYN flag on, but the ACK flag off, is sent to the server
2. Server then responds with a packet that has both the SYN and ACK flags turned on
3. Client sends back a packet with the SYN flag off but the ACK flag on.
4. Subsequent packets always have ACK flag on but SYN flag off
SYN flag is only for the first two packets, since those packets are used to synchronize sequence numbers.
Sequence numbers allow TPC to put unordered packets back into order.
When a connection is initiated:
1. Each side generates an initial sequence number
2. This number is communicated to the other side in the first 2 SYN packets
3. With each packet sent, the sequence number is incremented by the number of bytes found in the data portion of the packet.
This sequence number is included in the TCP packet header.
Each TCP header also has an acknowledgement number, which is simply the other side's sequence number plus one.

Unlike TCP, UDP has less built-in functionality than TCP, and behaves much like the IP protocol: connectionless and unreliable.
UDP expects the application to deal with these issues
See also: [UDP Protocol](https://www.rfc-editor.org/rfc/rfc768.html)

#### Raw Sockets
When using stream sockets, the data is neatly wrapped in a TCP/IP connection.
The operating system takes care of all of the lower-level details of transmission, correction, and routing.
We can access the network at lower levels using raw sockets.
Raw sockets are specified by using `SOCK_RAW` as the type, and the protocol could be
- `IPPROTO_TCP`
- `IPPROTO_UDP`
- `IPPROTO_ICMP`
Also, raw socket code is inconsistent between systems, what works for linux won't work on bsd or solaris.

There is however, a standardized programming library called `libpcap` which can be used to smooth out the inconsistencies of raw sockets.
Both `tcpdump` and `dnsiff` use `libpcap`

#### Decoding the layers
In packet captures, the outermost is Ethernet, which is also the lowest visible layer.
This layer sends data between ethernet end-points with MAC addresses.

The header for this layer contains:
- source MAC address
- dest MAC address
- 16-bit value that describes the type of ethernet packet

On linux, you can see the structure for 
- this header: `/usr/include/linux/if_ether.h`
- IP header: `/usr/include/netinet/ip.h`
- TCP header: `/usr/include/netinet/tcp.h`
We could also create our header structures based on the RFCs.

**Top tip: use `grep -rn -A10 <search_string>` when looking through libraries**

Take a look a the definition of the ethernet header:
```c
#define ETH_ALEN 6 /* Octets in one ethernet addr */
#define ETH_HLEN 14 /* Total octets in header */

struct ethhdr {
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	__be16		h_proto;		/* packet type ID field	*/
} __attribute__((packed));
```
`ETH_HLEN` is 14 bytes since source + dest MAC addresses is 6 + 6, and the packet type field is a 16-bit short integer that takes up 2 bytes.
Many compilers pad structures along 4-byte boundaries for alignment however, so using `sizeof(ethhdr)` will not give the right size.

`libpcap` has a function called `pcap_loop()` which is a better way to capture packets than just looping on a `pcap_next()` call.
`pcap_loop()` is a callback function, you pass in a function pointer, which is called evrey time a packet is captured. 
```c
int pcap_loop(pcap_t *handle, int count, pcap_handler callback, u_char *args);
```
1. A `pcap_t` pointer is used to reference a packet-capturing object, similar to a file descriptor.
2. Count is how many packets to capture, if set to `-1` it'll run forever until program break
3. The `pcap_handler` is an optional pointer that will get passed to the callback function.

Since the callback function must be called by `pcap_loop()`, we need to follow a certain prototype (althought it can be named whatever you like):
```c
void callback(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet);
```
1. the argument pointer is the same from the last function
2. pointer to the capture header
3. pointer to the packet itself

## Active Sniffing
