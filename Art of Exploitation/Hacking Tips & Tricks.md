## Environment Variables
We can use the environment variables to store shellcode that is too big to fit inside a buffer.
```sh
export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)
```
This would place the shellcode on the stack in an environment variable, along with a 200-byte NOP sled.

We can then find an address somewhere in that range of the sled to overwrite the saved return address with.

The environment variables are located near the bottom of the stack, so that is where we should look in a debugger.
Use `esp` when on breakpoint main to find the bottom of the stack.

### Using `getenv()` 
`getenv()`, accepts the name of an environment variable as its only argument and returns the variable's memory address.
This provides a much more accurate prediction of where the same environment variable will be when the target program is run. (Still requires NOP sled, as it is NOT FULLY accurate)

The length of the name of the program being executed also has an affect on the address of the environment variables.

To know the exact difference in length between the names, we can test different names using the same program that runs `getenv()` and change the name from length 1, up to 4. Hence we can do something like this

```c
int main(int argc, char *argv[]) {
	char *ptr;

	const int diff = 2; // difference in length between names, experiment to find

	if (argc < 3) {
		printf("Usage: %s <environment var> <target program name>\n", argv[0]);
		exit(0);	
	}
	ptr = getenv(argv[1]); // Get env var location
	ptr += (strlen(argv[0]) - strlen(argv[2]))*diff; // Adjust for program name
	printf("%s will be at %p\n", argv[1], ptr);
}
```

Environment variables simplify things considerably, and can be used to make exploit code more reliable.



## Heap based overflows
When heap memory is freed by the `free()` command after being overflowed, errors in the heap headers are detected and the program is terminated. 
Similar to return address overwrite with stack overflows, there are control points within the heap architecture itself. 
Heap unlinking counters in glibc make heap unlinking in linux very difficult.
Depending on the exploit, we may not need heap header information to do magic, so by the time `free()` is called, it would be too late.

## `/etc/passwd`
The file has the following format delimited by colons, from left to right
1. login name
2. password
3. user id
4. group id
5. username
6. home directory
7. login shell
the password fields are all filled with the `x` character, since the encrypted passwords are stored elsewhere in a shadow file. (However, this field can contain the encrypted password)
Any entry in the password file that has a user ID of 0 will be given root privileges

The goal to editing this file would be to append an extra entry with both root privileges and a known password to the password file.

### Encryption 
Salt value is always at the beginning of the hash. 

When a user logs in and enters a password, 
1. the system looks up the encrypted password for that user.
2. Finds the salt value from the stored encrypted password
3. The system uses the same one-way hashing algorithm to encrypt whatever text the user typed as the password
4. The system then compares to 2 hashes

This allows the password to be used for authentication without requiring that the password be stored anywhere in the system

## `printf()`
when the `printf()` argument is called, the arguments are pushed to the stack in reverse order. 
```c
printf("A is %d and is at %08x. B is at %x.\n", A, &A, B);
```
First the value of B, then the address of A, then the value of A, and finally the address of the format string.

The format function:
1. iterates through the format string one character at a time
2. If not the beginning of a format parameter, i.e, `%`
	1. character is copied to the output
3. if format character, argument in the stack is used, if argument is not there, whatever is there is used (the address is just incremented)

When coding, never use `printf(string)`, always do `printf("%s", string)`

By exploiting this, we can examine the lower stack memory by simply putting format parameters in the string
```sh
./fmt_vuln $(perl -e 'print "%08x."x40')
```
Remember that each four-byte word is backward, due to the little-endian architecture.

### reading from arbitrary memory address
the `%s` parameter can be used to read from arbitrary memory addresses. 

Since the format string is the last thing to be in argument stack, if we simply provide more format parameters than required, we would start to reference the format string itself.
In doing so, as long as we put the memory address we want to read in front of the string, we can use `%s` to read that address.

```sh
./fmt_vuln $(printf "\xef\xbe\xad\xde")%08x.%08x.%08x.%s
```
or however many `%08x.` we need to get to the start of the string. these can be omitted once we know the distance between the end of the stack frame and the beginning of the format string memory

### writing to arbitrary memory address
We can use the same technique and `%n` to write to an arbitrary memory address.